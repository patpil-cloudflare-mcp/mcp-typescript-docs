/**
 * Output Validation Module
 *
 * Validates that tool responses conform to expected formats and constraints:
 * - Type validation (string, object, array)
 * - Schema compliance
 * - Size/length validation
 * - Content warnings
 */
const DEFAULT_OPTIONS = {
    expectedType: 'any',
    maxSizeBytes: undefined,
    maxLength: undefined,
    warnOnErrorDetails: true,
    warnOnDatabaseData: true,
    warnOnCodeSnippets: false,
    allowedKeys: [],
};
/**
 * Patterns that indicate internal error details
 */
const ERROR_DETAIL_PATTERNS = [
    /at .+:\d+:\d+/i, // Stack traces: "at function:line:col"
    /error|exception/i, // Error keywords
    /undefined is not/i, // Common JS errors
    /cannot read property/i,
    /\[object Object\]/i,
    /null|undefined/i,
    /traceback|stacktrace/i,
];
/**
 * Patterns that indicate database data
 */
const DATABASE_PATTERNS = [
    /(?:select|insert|update|delete|drop)\s+/i,
    /\bfrom\b.*\bwhere\b/i,
    /table.*column/i,
    /database.*error/i,
];
/**
 * Patterns that indicate code snippets
 */
const CODE_PATTERNS = [
    /function\s+\w+\s*\(/,
    /const\s+\w+\s*=\s*/,
    /import.*from/i,
    /class\s+\w+/,
    /def\s+\w+\s*\(/,
];
/**
 * Validate output response format and content
 *
 * @param output - The output to validate
 * @param options - Validation options
 * @returns Validation result with errors and warnings
 *
 * @example
 * ```typescript
 * const result = validateOutput(toolOutput, {
 *   expectedType: 'object',
 *   maxSizeBytes: 10000,
 *   warnOnErrorDetails: true
 * });
 *
 * if (!result.valid) {
 *   console.error('Validation errors:', result.errors);
 * }
 * if (result.warnings.length > 0) {
 *   console.warn('Validation warnings:', result.warnings);
 * }
 * ```
 */
export function validateOutput(output, options = {}) {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    const errors = [];
    const warnings = [];
    let type = typeof output;
    let size = 0;
    let length;
    let keys = [];
    // Determine actual type
    if (Array.isArray(output)) {
        type = 'array';
        length = output.length;
    }
    else if (output === null) {
        type = 'null';
    }
    // Calculate size
    try {
        const json = JSON.stringify(output);
        size = new TextEncoder().encode(json).length;
    }
    catch {
        errors.push('Output is not JSON serializable');
    }
    // Type validation
    if (opts.expectedType &&
        opts.expectedType !== 'any' &&
        type !== opts.expectedType) {
        errors.push(`Expected type ${opts.expectedType}, got ${type}`);
    }
    // Size validation
    if (opts.maxSizeBytes && size > opts.maxSizeBytes) {
        errors.push(`Output size ${size} bytes exceeds maximum ${opts.maxSizeBytes} bytes`);
    }
    // Length validation
    if (opts.maxLength && typeof output === 'string' && output.length > opts.maxLength) {
        errors.push(`String length ${output.length} exceeds maximum ${opts.maxLength}`);
        length = output.length;
    }
    // Object-specific validation
    if (typeof output === 'object' && output !== null && !Array.isArray(output)) {
        keys = Object.keys(output);
        // Validate allowed keys
        if (opts.allowedKeys && opts.allowedKeys.length > 0) {
            const invalidKeys = keys.filter(k => !opts.allowedKeys.includes(k));
            if (invalidKeys.length > 0) {
                warnings.push(`Object contains unexpected keys: ${invalidKeys.join(', ')}`);
            }
        }
    }
    // Content warnings
    const outputStr = JSON.stringify(output);
    if (opts.warnOnErrorDetails && hasErrorDetails(outputStr)) {
        warnings.push('Output appears to contain error details or stack traces. Consider redacting before returning to user.');
    }
    if (opts.warnOnDatabaseData && hasDatabasePatterns(outputStr)) {
        warnings.push('Output appears to contain SQL or database information. Ensure this is intentional.');
    }
    if (opts.warnOnCodeSnippets && hasCodePatterns(outputStr)) {
        warnings.push('Output appears to contain code snippets. Consider whether this is sensitive.');
    }
    return {
        valid: errors.length === 0,
        errors,
        warnings,
        metadata: {
            type,
            size,
            length,
            keys: keys.length > 0 ? keys : undefined,
        },
    };
}
/**
 * Check if text contains error details/stack traces
 *
 * @param text - Text to check
 * @returns True if error patterns detected
 */
function hasErrorDetails(text) {
    return ERROR_DETAIL_PATTERNS.some(pattern => pattern.test(text));
}
/**
 * Check if text contains database patterns
 *
 * @param text - Text to check
 * @returns True if database patterns detected
 */
function hasDatabasePatterns(text) {
    return DATABASE_PATTERNS.some(pattern => pattern.test(text));
}
/**
 * Check if text contains code patterns
 *
 * @param text - Text to check
 * @returns True if code patterns detected
 */
function hasCodePatterns(text) {
    return CODE_PATTERNS.some(pattern => pattern.test(text));
}
/**
 * Strict validation that returns null if validation fails
 * Useful for failsafe operations
 *
 * @param output - Output to validate
 * @param options - Validation options
 * @returns Output if valid, null if invalid
 */
export function validateOutputStrict(output, options = {}) {
    const result = validateOutput(output, options);
    return result.valid ? output : null;
}
/**
 * Get human-readable validation report
 *
 * @param output - Output to validate
 * @param options - Validation options
 * @returns Human-readable validation report string
 */
export function getValidationReport(output, options = {}) {
    const result = validateOutput(output, options);
    const lines = [];
    lines.push('=== Output Validation Report ===');
    lines.push(`Status: ${result.valid ? '✅ VALID' : '❌ INVALID'}`);
    lines.push(`Type: ${result.metadata.type}`);
    lines.push(`Size: ${result.metadata.size} bytes`);
    if (result.metadata.length !== undefined) {
        lines.push(`Length: ${result.metadata.length}`);
    }
    if (result.errors.length > 0) {
        lines.push('\nErrors:');
        result.errors.forEach(e => lines.push(`  - ${e}`));
    }
    if (result.warnings.length > 0) {
        lines.push('\nWarnings:');
        result.warnings.forEach(w => lines.push(`  - ${w}`));
    }
    if (result.metadata.keys && result.metadata.keys.length > 0) {
        lines.push(`\nObject Keys: ${result.metadata.keys.join(', ')}`);
    }
    return lines.join('\n');
}
